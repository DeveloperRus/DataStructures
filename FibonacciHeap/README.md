# Фибоначчиева куча
> Для большего понимания реализации рекомендуется к прочтению книга "Алгоритмы. Построение и анализ"  Томас Х. Кормен 

**`Данная структура данных была проверена на тестирующих системах: ACMP и PCMS2`**

Так же, как и биномиальные пирамиды, фибоначчиевы пирамиды не способны обеспечить эффективную поддержку процедуры поиска 
Search, поэтому в процедуры в качестве параметра передаётся не ключ, а указатель на узел. 

**Время выполнения операций**

|  Процедура  | Амортизированная сложность |
|:-----------:|:--------------------------:|
|   MakeHeap  |            O(1)            |
|    Insert   |            O(1)            |
|    GetMin   |            O(1)            |
|    Merge    |            O(1)            |
|  ExtractMin |          O(Lg(n))          |
| DecreaseKey |            O(1)            |
|   Delete    |          O(Lg(n))          |

**Недостатки**

* Большое потребление памяти на узел (минимум 21 байт).
* Большая константа времени работы, что делает ее малоприменимой для реальных задач
* Некоторые операции в худшем случае могут работать за **O(n)** времени
* Сложность в реализации

**Достоинства**

* Одно из лучших амортизированных времен работы для всех операций

Фибоначчиевы кучи особенно полезны в случае, когда колличество операций `extractMin` и `Delete` (в данной реализации данная операция 
не представлена, так как в ней не было необходимости) относительно мало по сравнению с количеством других операций. Например, некоторые алгоритмы в задачах о графах вызывают процедуру `decreaseKey` для каждого ребра. В плотных графах с большим колличесвтом ребер амортизированное время работы процедуры **O(1)** даёт существенный выйгрыш по сравнению со временем **O(Lg(n))** в наихудшем случае.
(Поиск минимального остовного дерева или поиск кратчайшего пути из одной вершины преимущественно опираются на Фибоначчиевы пирамиды)

**Реализация**

В файле [FibonacciHeap.h](https://github.com/DeveloperRus/Cpp/blob/master/DataStructures/FibonacciHeap/FibonacciHeap.h) представлена реализация данной структуры данных.  

# Применение кучи в алгоритме Дейкстры 
> **Нахождение кратчайших путей от заданной вершины до всех остальных вершин.** Дан ориентированный или неориентированный взвешенный граф с n вершинами и m рёбрами. Веса всех рёбер неотрицательны. Указана некоторая стартовая вершина s. Требуется найти длины кратчайших путей из вершины s во все остальные вершины

Сложность алгоритма Дейкстры складывается из двух основных операций: время нахождения вершины с наименьшей величиной расстояния (`getMin`) и время совершения релаксации, т.е. время изменения величины (`decreaseKey`). Первая операция всего выполняется **O(n)** раз, а вторая — **O(m)**. Фибоначчиевы кучи позволяют производить эти операции соответсвенно за **O(Lg(n))** и **O(1)**, то есть время работы алгоритма Дейкстры составит **O(n*Lg(n) + m)**.

**Реализация**

В файле [main.cpp](https://github.com/DeveloperRus/Cpp/blob/master/DataStructures/FibonacciHeap/main.cpp) представлена реализация данного алгоритма с применением Фибоначчиевой кучи в контексте
задачи [Task.pdf](https://github.com/DeveloperRus/Cpp/blob/master/DataStructures/FibonacciHeap/Task.pdf)
